{"version":3,"file":"index.mjs","sources":["../../../src/dom/meta-node.mjs","../src/app/hydrate.mjs"],"sourcesContent":["// https://html.spec.whatwg.org/multipage/syntax.html#void-elements\nconst isVoidElement = element =>\n  [\n    \"base\",\n    \"link\",\n    \"meta\",\n\n    \"hr\",\n    \"br\",\n    \"wbr\",\n\n    \"area\",\n    \"img\",\n    \"track\",\n\n    \"embed\",\n    \"param\",\n    \"source\",\n\n    \"col\",\n\n    \"input\"\n  ].includes(element)\n\n// https://html.spec.whatwg.org/multipage/syntax.html#elements-2\n// https://html.spec.whatwg.org/multipage/syntax.html#cdata-rcdata-restrictions\nconst escapeForElement = x =>\n  (x + \"\")\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n\n// https://html.spec.whatwg.org/multipage/syntax.html#syntax-attribute-value\nconst escapeForDoubleQuotedAttribute = x =>\n  (x + \"\")\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n\nconst isAttributes = x =>\n  !(x instanceof MetaNode || x instanceof MetaRawString) &&\n  typeof x == \"object\"\n\n// Meta Nodes\n\nexport class MetaNode {\n  constructor() {\n    this.properties = {}\n    this.tag = undefined\n  }\n\n  toString() {}\n\n  toNode() {}\n\n  addProperties(properties = {}) {\n    Object.assign(this.properties, properties)\n\n    return this\n  }\n\n  setTag(tag = \"\") {\n    this.tag = tag\n\n    return this\n  }\n}\n\nexport class MetaTextNode extends MetaNode {\n  constructor(textContent) {\n    super()\n    this.textContent = textContent\n  }\n\n  toString() {\n    return `<bruh-textnode style=\"all:unset;display:inline\" ${\n      this.tag\n        ? `data-bruh=\"${escapeForDoubleQuotedAttribute(this.tag)}\"`\n        : \"\"\n    }>${ escapeForElement(this.textContent) }</bruh-textnode>`\n  }\n\n  toNode() {\n    const node = document.createTextNode(this.textContent)\n    Object.assign(node, this.properties)\n    return node\n  }\n}\n\nexport class MetaElement extends MetaNode {\n  constructor(name, namespace) {\n    super()\n    this.name = name\n    this.namespace = namespace\n    this.children = []\n\n    this.attributes = {}\n    this.dataset = {}\n  }\n\n  toString() {\n    const datasetWithTag =\n      this.tag\n        ? Object.assign({}, this.dataset, { bruh: this.tag })\n        : this.dataset\n    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n    const attributes =\n      [\n        ...Object.entries(this.attributes),\n        ...Object.entries(datasetWithTag)\n          .map(([name, value]) => {\n            // https://html.spec.whatwg.org/multipage/dom.html#dom-domstringmap-setitem\n            const skewered = name.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`)\n            return [`data-${skewered}`, value]\n          })\n      ]\n        .map(([name, value]) =>\n          value == \"\"\n            ? ` ${name}`\n            : ` ${name}=\"${escapeForDoubleQuotedAttribute(value)}\"`\n        ).join(\"\")\n    // https://html.spec.whatwg.org/multipage/syntax.html#syntax-start-tag\n    const startTag = `<${this.name}${attributes}>`\n\n    if (isVoidElement(this.name))\n      return startTag\n    else {\n      const contents =\n        this.children\n          .map(child =>\n            (child instanceof MetaNode || child instanceof MetaRawString)\n              ? child.toString()\n              : escapeForElement(child)\n          ).join(\"\")\n      // https://html.spec.whatwg.org/multipage/syntax.html#end-tags\n      const endTag = `</${this.name}>`\n      return startTag + contents + endTag\n    }\n  }\n\n  toNode() {\n    const node =\n      this.namespace\n        ? document.createElementNS(this.namespace, this.name)\n        : document.createElement  (                this.name)\n\n    // Add children\n    node.append(...this.children\n      .map(child => {\n        if (child instanceof MetaNode)\n          return child.toNode()\n\n        if (child instanceof Node)\n          return child\n\n        return child + \"\" // Coerce to a string to become a bare text node\n      })\n    )\n    // Assign properties, attributes, and dataset\n    Object.assign(node, this.properties)\n    Object.entries(this.attributes)\n      .forEach(([name, value]) => node.setAttribute(name, value))\n    Object.assign(node.dataset, this.dataset)\n\n    return node\n  }\n\n  addAttributes(attributes = {}) {\n    Object.assign(this.attributes, attributes)\n\n    return this\n  }\n\n  addDataAttributes(dataAttributes = {}) {\n    Object.assign(this.dataset, dataAttributes)\n\n    return this\n  }\n\n  prepend(...xs) {\n    this.children.unshift(...xs)\n\n    return this\n  }\n\n  append(...xs) {\n    this.children.push(...xs)\n\n    return this\n  }\n}\n\nexport class MetaRawString {\n  constructor(string) {\n    this.string = string\n  }\n\n  toString() {\n    return this.string\n  }\n}\n\n// Convenience functions\n\nexport const t = textContent =>\n  new MetaTextNode(textContent)\n\nexport const textNodeFrom = element => {\n  if (element.localName != \"bruh-textnode\")\n    throw new TypeError(\"Should only be called on a <bruh-textnode> (the result of t().toString())\")\n\n  const textNode = document.createTextNode(element.textContent)\n  element.replaceWith(textNode)\n  return textNode\n}\n\nexport const e = (name, namespace) => (...variadic) => {\n  const meta = new MetaElement(name, namespace)\n\n  // Implement optional attributes as first argument\n  if (isAttributes(variadic[0]))\n    [meta.attributes, ...meta.children] = variadic\n  else {\n    meta.attributes = {}\n    meta.children = variadic\n  }\n\n  return meta\n}\n\nexport const rawString = string =>\n  new MetaRawString(string)\n","import { textNodeFrom } from \"bruh/dom/meta-node\"\n\nconst textNode = textNodeFrom(\n  document.querySelector(`[data-bruh=\"seconds\"]`)\n)\n\nlet seconds = 0\ntextNode.bruh = {\n  // This text node's state\n  get seconds() {\n    return seconds\n  },\n  set seconds(n) {\n    textNode.textContent = seconds = n\n    return seconds\n  },\n\n  interval: null,\n\n  // State transition functions\n  increment: () => ++textNode.bruh.seconds,\n  decrement: () => --textNode.bruh.seconds,\n\n  startClock() {\n    textNode.bruh.interval = setInterval(textNode.bruh.increment, 1000)\n  },\n  stopClock() {\n    clearInterval(textNode.bruh.interval)\n  }\n}\n\ntextNode.bruh.startClock()\n"],"names":["textNode","element","localName","TypeError","document","createTextNode","textContent","replaceWith","textNodeFrom","querySelector","seconds","bruh","n","interval","increment","decrement","[object Object]","setInterval","clearInterval","startClock"],"mappings":"AA6MO,MC3MDA,ED2MsBC,CAAAA,IAC1B,GAAyB,iBAArBA,EAAQC,UACV,MAAM,IAAIC,UAAU,6EAEtB,MAAMH,EAAWI,SAASC,eAAeJ,EAAQK,aAEjD,OADAL,EAAQM,YAAYP,GACbA,GCjNQQ,CACfJ,SAASK,cAAc,0BAGzB,IAAIC,EAAU,EACdV,EAASW,KAAO,CAEdD,cACE,OAAOA,GAETA,YAAYE,GAEV,OADAZ,EAASM,YAAcI,EAAUE,EAC1BF,GAGTG,SAAU,KAGVC,UAAW,MAAQd,EAASW,KAAKD,QACjCK,UAAW,MAAQf,EAASW,KAAKD,QAEjCM,aACEhB,EAASW,KAAKE,SAAWI,YAAYjB,EAASW,KAAKG,UAAW,MAEhEE,YACEE,cAAclB,EAASW,KAAKE,YAIhCb,EAASW,KAAKQ"}