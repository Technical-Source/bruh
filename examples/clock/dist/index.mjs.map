{"version":3,"file":"index.mjs","sources":["../../../src/dom/meta-node.mjs","../src/app/hydrate.mjs"],"sourcesContent":["// https://html.spec.whatwg.org/multipage/syntax.html#void-elements\nconst isVoidElement = element =>\n  [\n    \"base\",\n    \"link\",\n    \"meta\",\n\n    \"hr\",\n    \"br\",\n    \"wbr\",\n\n    \"area\",\n    \"img\",\n    \"track\",\n\n    \"embed\",\n    \"param\",\n    \"source\",\n\n    \"col\",\n\n    \"input\"\n  ].includes(element)\n\n// https://html.spec.whatwg.org/multipage/syntax.html#elements-2\n// https://html.spec.whatwg.org/multipage/syntax.html#cdata-rcdata-restrictions\nconst escapeForElement = x =>\n  (x + \"\")\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n\n// https://html.spec.whatwg.org/multipage/syntax.html#syntax-attribute-value\nconst escapeForDoubleQuotedAttribute = x =>\n  (x + \"\")\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n\nconst isAttributes = x =>\n  !(x instanceof MetaNode || x instanceof MetaRawString) &&\n  typeof x == \"object\"\n\n// Meta Nodes\n\nexport class MetaNode {\n  constructor() {\n    this.properties = {}\n  }\n\n  toString() {}\n\n  toNode() {}\n\n  addProperties(properties = {}) {\n    Object.assign(this.properties, properties)\n\n    return this\n  }\n}\n\nexport class MetaTextNode extends MetaNode {\n  constructor(textContent) {\n    super()\n    this.textContent = textContent\n    this.tag = undefined\n  }\n\n  toString() {\n    return `<bruh-textnode style=\"all:unset;display:inline\"${\n      this.tag\n        ? ` data-tag=\"${escapeForDoubleQuotedAttribute(this.tag)}\"`\n        : \"\"\n    }>${ escapeForElement(this.textContent) }</bruh-textnode>`\n  }\n\n  toNode() {\n    const node = document.createTextNode(this.textContent)\n    Object.assign(node, this.properties)\n    return node\n  }\n\n  setTag(tag = \"\") {\n    this.tag = tag\n\n    return this\n  }\n}\n\nexport class MetaElement extends MetaNode {\n  constructor(name, namespace) {\n    super()\n    this.name = name\n    this.namespace = namespace\n    this.children = []\n\n    this.attributes = {}\n    this.dataset = {}\n  }\n\n  toString() {\n    const datasetWithTag =\n      this.tag\n        ? Object.assign({}, this.dataset, { bruh: this.tag })\n        : this.dataset\n    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n    const attributes =\n      [\n        ...Object.entries(this.attributes),\n        ...Object.entries(datasetWithTag)\n          .map(([name, value]) => {\n            // https://html.spec.whatwg.org/multipage/dom.html#dom-domstringmap-setitem\n            const skewered = name.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`)\n            return [`data-${skewered}`, value]\n          })\n      ]\n        .map(([name, value]) =>\n          value == \"\"\n            ? ` ${name}`\n            : ` ${name}=\"${escapeForDoubleQuotedAttribute(value)}\"`\n        ).join(\"\")\n    // https://html.spec.whatwg.org/multipage/syntax.html#syntax-start-tag\n    const startTag = `<${this.name}${attributes}>`\n\n    if (isVoidElement(this.name))\n      return startTag\n    else {\n      const contents =\n        this.children\n          .map(child =>\n            (child instanceof MetaNode || child instanceof MetaRawString)\n              ? child.toString()\n              : escapeForElement(child)\n          ).join(\"\")\n      // https://html.spec.whatwg.org/multipage/syntax.html#end-tags\n      const endTag = `</${this.name}>`\n      return startTag + contents + endTag\n    }\n  }\n\n  toNode() {\n    const node =\n      this.namespace\n        ? document.createElementNS(this.namespace, this.name)\n        : document.createElement  (                this.name)\n\n    // Add children\n    node.append(...this.children\n      .map(child => {\n        if (child instanceof MetaNode)\n          return child.toNode()\n\n        if (child instanceof Node)\n          return child\n\n        return child + \"\" // Coerce to a string to become a bare text node\n      })\n    )\n    // Assign properties, attributes, and dataset\n    Object.assign(node, this.properties)\n    Object.entries(this.attributes)\n      .forEach(([name, value]) => node.setAttribute(name, value))\n    Object.assign(node.dataset, this.dataset)\n\n    return node\n  }\n\n  addAttributes(attributes = {}) {\n    Object.assign(this.attributes, attributes)\n\n    return this\n  }\n\n  addDataAttributes(dataAttributes = {}) {\n    Object.assign(this.dataset, dataAttributes)\n\n    return this\n  }\n\n  prepend(...xs) {\n    this.children.unshift(...xs)\n\n    return this\n  }\n\n  append(...xs) {\n    this.children.push(...xs)\n\n    return this\n  }\n}\n\nexport class MetaRawString {\n  constructor(string) {\n    this.string = string\n  }\n\n  toString() {\n    return this.string\n  }\n}\n\n// Convenience functions\n\nexport const t = textContent =>\n  new MetaTextNode(textContent)\n\nexport const hydrateTextNodes = () => {\n  const tagged = {}\n  const bruhTextNodes = document.getElementsByTagName(\"bruh-textnode\")\n\n  for (const bruhTextNode of bruhTextNodes) {\n    const textNode = document.createTextNode(bruhTextNode.textContent)\n\n    if (bruhTextNode.dataset.tag)\n      tagged[bruhTextNode.dataset.tag] = textNode\n\n    bruhTextNode.replaceWith(textNode)\n  }\n  \n  return tagged\n}\n\nexport const e = (name, namespace) => (...variadic) => {\n  const meta = new MetaElement(name, namespace)\n\n  // Implement optional attributes as first argument\n  if (isAttributes(variadic[0]))\n    [meta.attributes, ...meta.children] = variadic\n  else {\n    meta.attributes = {}\n    meta.children = variadic\n  }\n\n  return meta\n}\n\nexport const rawString = string =>\n  new MetaRawString(string)\n","import { hydrateTextNodes } from \"bruh/dom/meta-node\"\n\nconst { seconds: textNode } = hydrateTextNodes()\n\nlet seconds = 0\ntextNode.bruh = {\n  // This text node's state\n  get seconds() {\n    return seconds\n  },\n  set seconds(n) {\n    textNode.textContent = seconds = n\n    return seconds\n  },\n\n  interval: null,\n\n  // State transition functions\n  increment: () => ++textNode.bruh.seconds,\n  decrement: () => --textNode.bruh.seconds,\n\n  startClock() {\n    textNode.bruh.interval = setInterval(textNode.bruh.increment, 1000)\n  },\n  stopClock() {\n    clearInterval(textNode.bruh.interval)\n  }\n}\n\ntextNode.bruh.startClock()\n"],"names":["seconds","textNode","tagged","bruhTextNodes","document","getElementsByTagName","bruhTextNode","createTextNode","textContent","dataset","tag","replaceWith","hydrateTextNodes","bruh","n","interval","increment","decrement","[object Object]","setInterval","clearInterval","startClock"],"mappings":"AA6MO,MC3MCA,QAASC,GD2Me,MAC9B,MAAMC,EAAS,GACTC,EAAgBC,SAASC,qBAAqB,iBAEpD,IAAK,MAAMC,KAAgBH,EAAe,CACxC,MAAMF,EAAWG,SAASG,eAAeD,EAAaE,aAElDF,EAAaG,QAAQC,MACvBR,EAAOI,EAAaG,QAAQC,KAAOT,GAErCK,EAAaK,YAAYV,GAG3B,OAAOC,GCxNqBU,GAE9B,IAAIZ,EAAU,EACdC,EAASY,KAAO,CAEdb,cACE,OAAOA,GAETA,YAAYc,GAEV,OADAb,EAASO,YAAcR,EAAUc,EAC1Bd,GAGTe,SAAU,KAGVC,UAAW,MAAQf,EAASY,KAAKb,QACjCiB,UAAW,MAAQhB,EAASY,KAAKb,QAEjCkB,aACEjB,EAASY,KAAKE,SAAWI,YAAYlB,EAASY,KAAKG,UAAW,MAEhEE,YACEE,cAAcnB,EAASY,KAAKE,YAIhCd,EAASY,KAAKQ"}