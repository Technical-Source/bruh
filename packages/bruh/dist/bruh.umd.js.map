{"version":3,"file":"bruh.umd.js","sources":["../src/dom/live-fragment.mjs","../src/reactive/index.mjs","../src/util/index.mjs","../src/dom/index.browser.mjs"],"sourcesContent":["// Lightweight and performant DOM fragment that keeps its place,\n// useful for grouping siblings without making a parent element.\n// Not a true analog of the DocumentFragment, because the implementation\n// would be infeasible with that scope, adding a performance penalty as well.\n// Works as long as the start & end placeholders are siblings in that order\n// and they do not overlap other LiveFragment's:\n// Works: (start A)(start B)(end B)(end A)\n// Fails: (start A)(start B)(end A)(end B)\n// Also, make sure not to call .normalize() on the parent element,\n// because that would ruin the placeholders.\nexport class LiveFragment {\n  startMarker = document.createTextNode(\"\")\n  endMarker   = document.createTextNode(\"\")\n\n  static from(firstNode, lastNode) {\n    const liveFragment = new this()\n    firstNode.before(liveFragment.startMarker)\n    lastNode.after(liveFragment.endMarker)\n    return liveFragment\n  }\n\n  before(...xs) {\n    this.startMarker.before(...xs)\n  }\n\n  prepend(...xs) {\n    this.startMarker.after(...xs)\n  }\n\n  append(...xs) {\n    this.endMarker.before(...xs)\n  }\n\n  after(...xs) {\n    this.endMarker.after(...xs)\n  }\n\n  remove() {\n    const range = document.createRange()\n    range.setStartBefore(this.startMarker)\n    range.setEndAfter(this.endMarker)\n    range.deleteContents()\n  }\n\n  replaceChildren(...xs) {\n    const range = document.createRange()\n    range.setStartAfter(this.startMarker)\n    range.setEndBefore(this.endMarker)\n    range.deleteContents()\n    this.startMarker.after(...xs)\n  }\n\n  replaceWith(...xs) {\n    this.endMarker.after(...xs)\n    this.remove()\n  }\n\n  get childNodes() {\n    const childNodes = []\n\n    for (\n      let currentNode = this.startMarker.nextSibling;\n      currentNode != this.endMarker && currentNode;\n      currentNode = currentNode.nextSibling\n    )\n      childNodes.push(currentNode)\n\n    return childNodes\n  }\n\n  get children() {\n    return this.childNodes\n      .filter(node => node instanceof HTMLElement)\n  }\n}\n","const isReactive = Symbol.for(\"bruh reactive\")\n\n// A super simple and performant reactive value implementation\nexport class SimpleReactive {\n  [isReactive] = true\n\n  #value\n  #reactions = new Set()\n\n  constructor(value) {\n    this.#value = value\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  set value(newValue) {\n    if (newValue === this.#value)\n      return\n\n    this.#value = newValue\n    for (const reaction of this.#reactions)\n      reaction()\n  }\n\n  addReaction(reaction) {\n    this.#reactions.add(reaction)\n\n    return () =>\n      this.#reactions.delete(reaction)\n  }\n}\n\n// A reactive implementation for building functional reactive graphs\n// Ensures state consistency, minimal node updates, and transparent update batching\nexport class FunctionalReactive {\n  [isReactive] = true\n\n  #value\n  #reactions = new Set()\n\n  // For derived nodes, f is the derivation function\n  #f\n  // Source nodes are 0 deep in the derivation graph\n  // This is for topological sort\n  #depth = 0\n  // All nodes have a set of derivatives that update when the node changes\n  #derivatives = new Set()\n\n  // Keep track of all the pending changes from the value setter\n  static #settersQueue = new Map()\n  // A queue of derivatives to potentially update, sorted into sets by depth\n  // This starts with depth 1 and can potentially have holes\n  static #derivativesQueue = []\n  // A queue of reactions to run after the graph is fully updated\n  static #reactionsQueue = []\n\n  constructor(x, f) {\n    if (!f) {\n      this.#value = x\n      return\n    }\n\n    this.#value = f()\n    this.#f = f\n    this.#depth = Math.max(...x.map(d => d.#depth)) + 1\n\n    x.forEach(d => d.#derivatives.add(this))\n  }\n\n  get value() {\n    // If there are any pending updates, go ahead and apply them first\n    // It's ok that there's already a microtask queued for this\n    if (FunctionalReactive.#settersQueue.size)\n      FunctionalReactive.applyUpdates()\n\n    return this.#value\n  }\n\n  set value(newValue) {\n    // Only allow souce nodes to be directly updated\n    if (this.#depth !== 0)\n      return\n\n    // Unless asked for earlier, these updates are just queued up until the microtasks run\n    if (!FunctionalReactive.#settersQueue.size)\n      queueMicrotask(FunctionalReactive.applyUpdates)\n\n    FunctionalReactive.#settersQueue.set(this, newValue)\n  }\n\n  addReaction(reaction) {\n    this.#reactions.add(reaction)\n\n    return () =>\n      this.#reactions.delete(reaction)\n  }\n\n  // Apply an update for a node and queue its derivatives if it actually changed\n  #applyUpdate(newValue) {\n    if (newValue === this.#value)\n      return\n\n    this.#value = newValue\n    FunctionalReactive.#reactionsQueue.push(...this.#reactions)\n\n    const queue = FunctionalReactive.#derivativesQueue\n    for (const derivative of this.#derivatives) {\n      const depth = derivative.#depth\n      if (!queue[depth])\n        queue[depth] = new Set()\n\n      queue[depth].add(derivative)\n    }\n  }\n\n  // Apply pending updates from actually changed source nodes\n  static applyUpdates() {\n    if (!FunctionalReactive.#settersQueue.size)\n      return\n\n    // Bootstrap by applying the updates from the pending setters\n    for (const [sourceNode, newValue] of FunctionalReactive.#settersQueue.entries())\n      sourceNode.#applyUpdate(newValue)\n    FunctionalReactive.#settersQueue.clear()\n\n    // Iterate down the depths, ignoring holes\n    // Note that both the queue (Array) and each depth Set iterators update as items are added\n    for (const depthSet of FunctionalReactive.#derivativesQueue) if (depthSet)\n      for (const derivative of depthSet)\n        derivative.#applyUpdate(derivative.#f())\n    FunctionalReactive.#derivativesQueue.length = 0\n\n    // Call all reactions now that the graph has a fully consistent state\n    for (const reaction of FunctionalReactive.#reactionsQueue)\n      reaction()\n    FunctionalReactive.#reactionsQueue.length = 0\n  }\n}\n\n// A little convenience function\nexport const r = (x, f) => new FunctionalReactive(x, f)\n\n// Do something with a value, updating if it is reactive\nexport const reactiveDo = (x, f) => {\n  if (x?.[isReactive]) {\n    f(x.value)\n    return x.addReaction(() => f(x.value))\n  }\n\n  f(x)\n}\n","// Create a pipeline with an initial value and a series of functions\nexport const pipe = (x, ...fs) =>\n  fs.reduce((y, f) => f(y), x)\n\n// Dispatch a custom event to (capturing) and from (bubbling) a target (usually a DOM node)\n// Returns false if the event was cancelled (preventDefault()) and true otherwise\nexport const dispatch = (target, type, options) =>\n  target.dispatchEvent(\n    // Default to behave like most DOM events\n    new CustomEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      ...options\n    })\n  )\n\n// Inspired by https://antfu.me/posts/destructuring-with-object-or-array#take-away\n// Creates an object that is both destructable with {...} and [...]\n// Useful for writing library functions Ã  la react-use & vueuse\nexport const createDestructable = (object, iterable) => {\n  const destructable = {\n    ...object,\n    [Symbol.iterator]: () => iterable[Symbol.iterator]()\n  }\n\n  Object.defineProperty(destructable, Symbol.iterator, {\n    enumerable: false\n  })\n\n  return destructable\n}\n\n// A function that acts like Maybe.from(x).ifExists(existsThen).ifEmpty(emptyThen)\n// Except we just use an array in place of a true Maybe type\n// This is useful for setting and removing reactive attributes\nexport const maybeDo = (existsThen, emptyThen) => x => {\n  if (Array.isArray(x)) {\n    if (x.length)\n      existsThen(x[0])\n    else\n      emptyThen()\n  }\n  else\n    existsThen(x)\n}\n\n// Creates an object (as a Proxy) that acts as a function\n// So functionAsObject(f).property is equivalent to f(\"property\")\n// This is can be useful when combined with destructuring syntax, e.g.:\n// const { html, head, title, body, main, h1, p } = functionAsObject(e)\nexport const functionAsObject = f =>\n  new Proxy({}, {\n    get: (_, property) => f(property)\n  })\n","import { LiveFragment } from \"./live-fragment.mjs\"\nimport { reactiveDo } from \"../reactive/index.mjs\"\nimport { maybeDo } from \"../util/index.mjs\"\n\nconst isReactive     = Symbol.for(\"bruh reactive\")\nconst isMetaNode     = Symbol.for(\"bruh meta node\")\nconst isMetaTextNode = Symbol.for(\"bruh meta text node\")\nconst isMetaElement  = Symbol.for(\"bruh meta element\")\n\n// A basic check for if a value is allowed as a meta node's child\n// It's responsible for quickly checking the type, not deep validation\nconst isMetaNodeChild = x =>\n  // meta nodes, reactives, and DOM nodes\n  x?.[isMetaNode] ||\n  x?.[isReactive] ||\n  x instanceof Node ||\n  // Any array, just assume it contains valid children\n  Array.isArray(x) ||\n  // Allow nullish\n  x == null ||\n  // Disallow functions and objects\n  !(typeof x === \"function\" || typeof x === \"object\")\n  // Everything else can be a child when stringified\n\nconst toNode = x => {\n  if (x[isMetaNode])\n    return x.node\n\n  if (x instanceof Node)\n    return x\n\n  return document.createTextNode(x)\n}\n\nexport const childrenToNodes = children =>\n  children\n    .flat(Infinity)\n    .flatMap(child => {\n      if (!child[isReactive])\n        return [toNode(child)]\n\n      if (Array.isArray(child.value)) {\n        const liveFragment = new LiveFragment()\n        child.addReaction(() => {\n          liveFragment.replaceChildren(...childrenToNodes(child.value))\n        })\n        return [liveFragment.startMarker, ...childrenToNodes(child.value), liveFragment.endMarker]\n      }\n\n      let node = toNode(child.value)\n      child.addReaction(() => {\n        const oldNode = node\n        node = toNode(child.value)\n        oldNode.replaceWith(node)\n      })\n      return [node]\n    })\n\n\n\n// Meta Nodes\n\nexport class MetaTextNode {\n  [isMetaNode]    = true;\n  [isMetaElement] = true\n\n  node\n\n  constructor(textContent) {\n    if (!textContent[isReactive]) {\n      this.node = document.createTextNode(textContent)\n      return\n    }\n\n    this.node = document.createTextNode(textContent.value)\n    textContent.addReaction(() => {\n      this.node.textContent = textContent.value\n    })\n  }\n\n  addProperties(properties = {}) {\n    Object.assign(this.node, properties)\n\n    return this\n  }\n}\n\nexport class MetaElement {\n  [isMetaNode]    = true;\n  [isMetaElement] = true\n\n  node\n\n  constructor(name, namespace) {\n    this.node =\n      namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement  (           name)\n  }\n\n  static from(element) {\n    const result = new this(\"div\")\n    result.node = element\n    return result\n  }\n\n  addProperties(properties = {}) {\n    Object.assign(this.node, properties)\n\n    return this\n  }\n\n  addAttributes(attributes = {}) {\n    for (const name in attributes)\n      reactiveDo(attributes[name],\n        maybeDo(\n          value => this.node.setAttribute   (name, value),\n          ()    => this.node.removeAttribute(name)\n        )\n      )\n\n    return this\n  }\n\n  addDataAttributes(dataAttributes = {}) {\n    for (const name in dataAttributes)\n      reactiveDo(dataAttributes[name],\n        maybeDo(\n          value =>        this.node.dataset[name] = value,\n          ()    => delete this.node.dataset[name]\n        )\n      )\n\n    return this\n  }\n\n  addStyles(styles = {}) {\n    for (const property in styles)\n      reactiveDo(styles[property],\n        maybeDo(\n          value => this.node.style.setProperty   (property, value),\n          ()    => this.node.style.removeProperty(property)\n        )\n      )\n\n    return this\n  }\n\n  toggleClasses(classes = {}) {\n    for (const name in classes)\n      reactiveDo(classes[name],\n        value => this.node.classList.toggle(name, value)\n      )\n\n    return this\n  }\n\n  before(...xs) {\n    this.node.before(...childrenToNodes(xs))\n  }\n\n  prepend(...xs) {\n    this.node.prepend(...childrenToNodes(xs))\n  }\n\n  append(...xs) {\n    this.node.append(...childrenToNodes(xs))\n  }\n\n  after(...xs) {\n    this.node.after(...childrenToNodes(xs))\n  }\n\n  replaceChildren(...xs) {\n    this.node.replaceChildren(...childrenToNodes(xs))\n  }\n\n  replaceWith(...xs) {\n    this.node.replaceWith(...childrenToNodes(xs))\n  }\n}\n\n\n\n// Convenience functions\n\nexport const hydrateTextNodes = () => {\n  const tagged = {}\n  const bruhTextNodes = document.getElementsByTagName(\"bruh-textnode\")\n\n  for (const bruhTextNode of bruhTextNodes) {\n    const textNode = document.createTextNode(bruhTextNode.textContent)\n\n    if (bruhTextNode.dataset.tag)\n      tagged[bruhTextNode.dataset.tag] = textNode\n\n    bruhTextNode.replaceWith(textNode)\n  }\n\n  return tagged\n}\n\nconst createMetaTextNode = textContent =>\n  new MetaTextNode(textContent)\n\nconst createMetaElement = (name, namespace) => (...variadic) => {\n  const meta = new MetaElement(name, namespace)\n\n  // Implement optional attributes as first argument\n  if (!isMetaNodeChild(variadic[0])) {\n    const [attributes, ...children] = variadic\n    meta.addAttributes(attributes)\n    meta.append(children)\n  }\n  else {\n    meta.append(variadic)\n  }\n\n  return meta\n}\n\n// JSX integration\nconst createMetaElementJSX = (nameOrComponent, attributesOrProps, ...children) => {\n  // If we are making a html element\n  // This is likely when the jsx tag name begins with a lowercase character\n  if (typeof nameOrComponent == \"string\") {\n    const meta = new MetaElement(nameOrComponent)\n\n    // These are attributes then, but they might be null/undefined\n    meta.addAttributes(attributesOrProps || {})\n    meta.append(children)\n\n    return meta\n  }\n\n  // It must be a component, then\n  // Bruh components are just functions that return meta elements\n  // Due to JSX, this would mean a function with only one parameter - a \"props\" object\n  // This object includes the all of the attributes and a \"children\" key\n  return nameOrComponent( Object.assign({}, attributesOrProps, { children }) )\n}\n\n// These will be called with short names\nexport {\n  createMetaTextNode   as t,\n  createMetaElement    as e,\n  createMetaElementJSX as h\n}\n\n// The JSX fragment is made into a bruh fragment (just an array)\nexport const JSXFragment = ({ children }) => children\n"],"names":["isReactive"],"mappings":"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"}