var e,t,r,a,n,o,s,i,d,c,l,h,u,p,f,b,m,v,y=Object.defineProperty,M=Object.defineProperties,g=Object.getOwnPropertyDescriptors,w=Object.getOwnPropertySymbols,k=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable,O=(e,t,r)=>t in e?y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,T=(e,t)=>{for(var r in t||(t={}))k.call(t,r)&&O(e,r,t[r]);if(w)for(var r of w(t))S.call(t,r)&&O(e,r,t[r]);return e},W=(e,t,r)=>(O(e,"symbol"!=typeof t?t+"":t,r),r),x=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},_=(e,t,r)=>(x(e,t,"read from private field"),r?r.call(e):t.get(e)),j=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},A=(e,t,r,a)=>(x(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r),N=(e,t,r)=>(x(e,t,"access private method"),r);class E{constructor(){W(this,"startMarker",document.createTextNode("")),W(this,"endMarker",document.createTextNode(""))}static from(e,t){const r=new this;return e.before(r.startMarker),t.after(r.endMarker),r}before(...e){this.startMarker.before(...e)}prepend(...e){this.startMarker.after(...e)}append(...e){this.endMarker.before(...e)}after(...e){this.endMarker.after(...e)}remove(){const e=document.createRange();e.setStartBefore(this.startMarker),e.setEndAfter(this.endMarker),e.deleteContents()}replaceChildren(...e){const t=document.createRange();t.setStartAfter(this.startMarker),t.setEndBefore(this.endMarker),t.deleteContents(),this.startMarker.after(...e)}replaceWith(...e){this.endMarker.after(...e),this.remove()}get childNodes(){const e=[];for(let t=this.startMarker.nextSibling;t!=this.endMarker&&t;t=t.nextSibling)e.push(t);return e}get children(){return this.childNodes.filter((e=>e instanceof HTMLElement))}}var C=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",LiveFragment:E});const P=Symbol.for("bruh reactive");e=P,t=new WeakMap,r=new WeakMap;const R=class{constructor(e,t){j(this,u),W(this,a,!0),j(this,n,void 0),j(this,o,new Set),j(this,s,void 0),j(this,i,0),j(this,d,new Set),t?(A(this,n,t()),A(this,s,t),A(this,i,Math.max(...e.map((e=>_(e,i))))+1),e.forEach((e=>_(e,d).add(this)))):A(this,n,e)}get value(){return _(R,c).size&&R.applyUpdates(),_(this,n)}set value(e){0===_(this,i)&&(_(R,c).size||queueMicrotask(R.applyUpdates),_(R,c).set(this,e))}addReaction(e){return _(this,o).add(e),()=>_(this,o).delete(e)}static applyUpdates(){var e,t,r;if(_(R,c).size){for(const[t,r]of _(R,c).entries())N(e=t,u,p).call(e,r);_(R,c).clear();for(const e of _(R,l))if(e)for(const a of e)N(r=a,u,p).call(r,_(t=a,s).call(t));_(R,l).length=0;for(const e of _(R,h))e();_(R,h).length=0}}};let z=R;a=P,n=new WeakMap,o=new WeakMap,s=new WeakMap,i=new WeakMap,d=new WeakMap,c=new WeakMap,l=new WeakMap,h=new WeakMap,u=new WeakSet,p=function(e){if(e===_(this,n))return;A(this,n,e),_(R,h).push(..._(this,o));const t=_(R,l);for(const r of _(this,d)){const e=_(r,i);t[e]||(t[e]=new Set),t[e].add(r)}},j(z,c,new Map),j(z,l,[]),j(z,h,[]);const D=(e,t)=>{if(null==e?void 0:e[P])return t(e.value),e.addReaction((()=>t(e.value)));t(e)};var B=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",SimpleReactive:class{constructor(a){W(this,e,!0),j(this,t,void 0),j(this,r,new Set),A(this,t,a)}get value(){return _(this,t)}set value(e){if(e!==_(this,t)){A(this,t,e);for(const e of _(this,r))e()}}addReaction(e){return _(this,r).add(e),()=>_(this,r).delete(e)}},FunctionalReactive:z,r:(e,t)=>new z(e,t),reactiveDo:D});const F=(e,t)=>r=>{Array.isArray(r)?r.length?e(r[0]):t():e(r)};var L=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",pipe:(e,...t)=>t.reduce(((e,t)=>t(e)),e),dispatch:(e,t,r)=>e.dispatchEvent(new CustomEvent(t,T({bubbles:!0,cancelable:!0,composed:!0},r))),createDestructable:(e,t)=>{const r=(a=T({},e),n={[Symbol.iterator]:()=>t[Symbol.iterator]()},M(a,g(n)));var a,n;return Object.defineProperty(r,Symbol.iterator,{enumerable:!1}),r},maybeDo:F,functionAsObject:e=>new Proxy({},{get:(t,r)=>e(r)})});const U=Symbol.for("bruh reactive"),q=Symbol.for("bruh meta node"),H=Symbol.for("bruh meta element"),I=e=>e[q]?e.node:e instanceof Node?e:document.createTextNode(e),J=e=>e.flat(1/0).flatMap((e=>{if(!e[U])return[I(e)];if(Array.isArray(e.value)){const t=new E;return e.addReaction((()=>{t.replaceChildren(...J(e.value))})),[t.startMarker,...J(e.value),t.endMarker]}let t=I(e.value);return e.addReaction((()=>{const r=t;t=I(e.value),r.replaceWith(t)})),[t]}));class X{constructor(e){W(this,f,!0),W(this,b,!0),W(this,"node"),e[U]?(this.node=document.createTextNode(e.value),e.addReaction((()=>{this.node.textContent=e.value}))):this.node=document.createTextNode(e)}addProperties(e={}){return Object.assign(this.node,e),this}}f=q,b=H;class G{constructor(e,t){W(this,m,!0),W(this,v,!0),W(this,"node"),this.node=t?document.createElementNS(t,e):document.createElement(e)}static from(e){const t=new this("div");return t.node=e,t}addProperties(e={}){return Object.assign(this.node,e),this}addAttributes(e={}){for(const t in e)D(e[t],F((e=>this.node.setAttribute(t,e)),(()=>this.node.removeAttribute(t))));return this}addDataAttributes(e={}){for(const t in e)D(e[t],F((e=>this.node.dataset[t]=e),(()=>delete this.node.dataset[t])));return this}addStyles(e={}){for(const t in e)D(e[t],F((e=>this.node.style.setProperty(t,e)),(()=>this.node.style.removeProperty(t))));return this}toggleClasses(e={}){for(const t in e)D(e[t],(e=>this.node.classList.toggle(t,e)));return this}before(...e){this.node.before(...J(e))}prepend(...e){this.node.prepend(...J(e))}append(...e){this.node.append(...J(e))}after(...e){this.node.after(...J(e))}replaceChildren(...e){this.node.replaceChildren(...J(e))}replaceWith(...e){this.node.replaceWith(...J(e))}}m=q,v=H;var K=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",childrenToNodes:J,MetaTextNode:X,MetaElement:G,hydrateTextNodes:()=>{const e={},t=document.getElementsByTagName("bruh-textnode");for(const r of t){const t=document.createTextNode(r.textContent);r.dataset.tag&&(e[r.dataset.tag]=t),r.replaceWith(t)}return e},t:e=>new X(e),e:(e,t)=>(...r)=>{const a=new G(e,t);if((null==(n=r[0])?void 0:n[q])||(null==n?void 0:n[U])||n instanceof Node||Array.isArray(n)||"function"!=typeof n)a.append(r);else{const[e,...t]=r;a.addAttributes(e),a.append(t)}var n;return a},h:(e,t,...r)=>{if("string"==typeof e){const a=new G(e);return a.addAttributes(t||{}),a.append(r),a}return e(Object.assign({},t,{children:r}))},JSXFragment:({children:e})=>e});export{K as dom,C as liveFragment,B as reactive,L as util};
//# sourceMappingURL=bruh.es.js.map
