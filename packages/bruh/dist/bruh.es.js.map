{"version":3,"file":"bruh.es.js","sources":["../src/dom/live-fragment.mjs","../src/reactive/index.mjs","../src/dom/index.browser.mjs","../src/util/index.mjs"],"sourcesContent":["// Lightweight and performant DOM fragment that keeps its place,\n// useful for grouping siblings without making a parent element.\n// Not a true analog of the DocumentFragment, because the implementation\n// would be infeasible with that scope, adding a performance penalty as well.\n// Works as long as the start & end placeholders are siblings in that order\n// and they do not overlap other LiveFragment's:\n// Works: (start A)(start B)(end B)(end A)\n// Fails: (start A)(start B)(end A)(end B)\n// Also, make sure not to call .normalize() on the parent element,\n// because that would ruin the placeholders.\nexport class LiveFragment {\n  startMarker = document.createTextNode(\"\")\n  endMarker   = document.createTextNode(\"\")\n\n  static from(firstNode, lastNode) {\n    const liveFragment = new this()\n    firstNode.before(liveFragment.startMarker)\n    lastNode.after(liveFragment.endMarker)\n    return liveFragment\n  }\n\n  before(...xs) {\n    this.startMarker.before(...xs)\n  }\n\n  prepend(...xs) {\n    this.startMarker.after(...xs)\n  }\n\n  append(...xs) {\n    this.endMarker.before(...xs)\n  }\n\n  after(...xs) {\n    this.endMarker.after(...xs)\n  }\n\n  remove() {\n    const range = document.createRange()\n    range.setStartBefore(this.startMarker)\n    range.setEndAfter(this.endMarker)\n    range.deleteContents()\n  }\n\n  replaceChildren(...xs) {\n    const range = document.createRange()\n    range.setStartAfter(this.startMarker)\n    range.setEndBefore(this.endMarker)\n    range.deleteContents()\n    this.startMarker.after(...xs)\n  }\n\n  replaceWith(...xs) {\n    this.endMarker.after(...xs)\n    this.remove()\n  }\n\n  get childNodes() {\n    const childNodes = []\n\n    for (\n      let currentNode = this.startMarker.nextSibling;\n      currentNode != this.endMarker && currentNode;\n      currentNode = currentNode.nextSibling\n    )\n      childNodes.push(currentNode)\n\n    return childNodes\n  }\n\n  get children() {\n    return this.childNodes\n      .filter(node => node instanceof HTMLElement)\n  }\n}\n","export const isReactive = Symbol.for(\"bruh reactive\")\n\n// A super simple and performant reactive value implementation\nexport class SimpleReactive {\n  [isReactive] = true\n\n  #value\n  #reactions = new Set()\n\n  constructor(value) {\n    this.#value = value\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  set value(newValue) {\n    if (newValue === this.#value)\n      return\n\n    this.#value = newValue\n    for (const reaction of this.#reactions)\n      reaction()\n  }\n\n  addReaction(reaction) {\n    this.#reactions.add(reaction)\n\n    return () =>\n      this.#reactions.delete(reaction)\n  }\n}\n\n// A reactive implementation for building functional reactive graphs\n// Ensures state consistency, minimal node updates, and transparent update batching\nexport class FunctionalReactive {\n  [isReactive] = true\n\n  #value\n  #reactions = new Set()\n\n  // For derived nodes, f is the derivation function\n  #f\n  // Source nodes are 0 deep in the derivation graph\n  // This is for topological sort\n  #depth = 0\n  // All nodes have a set of derivatives that update when the node changes\n  #derivatives = new Set()\n\n  // Keep track of all the pending changes from the value setter\n  static #settersQueue = new Map()\n  // A queue of derivatives to potentially update, sorted into sets by depth\n  // This starts with depth 1 and can potentially have holes\n  static #derivativesQueue = []\n  // A queue of reactions to run after the graph is fully updated\n  static #reactionsQueue = []\n\n  constructor(x, f) {\n    if (!f) {\n      this.#value = x\n      return\n    }\n\n    this.#value = f()\n    this.#f = f\n    this.#depth = Math.max(...x.map(d => d.#depth)) + 1\n\n    x.forEach(d => d.#derivatives.add(this))\n  }\n\n  get value() {\n    // If there are any pending updates, go ahead and apply them first\n    // It's ok that there's already a microtask queued for this\n    if (FunctionalReactive.#settersQueue.size)\n      FunctionalReactive.applyUpdates()\n\n    return this.#value\n  }\n\n  set value(newValue) {\n    // Only allow source nodes to be directly updated\n    if (this.#depth !== 0)\n      return\n\n    // Unless asked for earlier, these updates are just queued up until the microtasks run\n    if (!FunctionalReactive.#settersQueue.size)\n      queueMicrotask(FunctionalReactive.applyUpdates)\n\n    FunctionalReactive.#settersQueue.set(this, newValue)\n  }\n\n  addReaction(reaction) {\n    this.#reactions.add(reaction)\n\n    return () =>\n      this.#reactions.delete(reaction)\n  }\n\n  // Apply an update for a node and queue its derivatives if it actually changed\n  #applyUpdate(newValue) {\n    if (newValue === this.#value)\n      return\n\n    this.#value = newValue\n    FunctionalReactive.#reactionsQueue.push(...this.#reactions)\n\n    const queue = FunctionalReactive.#derivativesQueue\n    for (const derivative of this.#derivatives) {\n      const depth = derivative.#depth\n      if (!queue[depth])\n        queue[depth] = new Set()\n\n      queue[depth].add(derivative)\n    }\n  }\n\n  // Apply pending updates from actually changed source nodes\n  static applyUpdates() {\n    if (!FunctionalReactive.#settersQueue.size)\n      return\n\n    // Bootstrap by applying the updates from the pending setters\n    for (const [sourceNode, newValue] of FunctionalReactive.#settersQueue.entries())\n      sourceNode.#applyUpdate(newValue)\n    FunctionalReactive.#settersQueue.clear()\n\n    // Iterate down the depths, ignoring holes\n    // Note that both the queue (Array) and each depth Set iterators update as items are added\n    for (const depthSet of FunctionalReactive.#derivativesQueue) if (depthSet)\n      for (const derivative of depthSet)\n        derivative.#applyUpdate(derivative.#f())\n    FunctionalReactive.#derivativesQueue.length = 0\n\n    // Call all reactions now that the graph has a fully consistent state\n    for (const reaction of FunctionalReactive.#reactionsQueue)\n      reaction()\n    FunctionalReactive.#reactionsQueue.length = 0\n  }\n}\n\n// A little convenience function\nexport const r = (x, f) => new FunctionalReactive(x, f)\n\n// Do something with a value, updating if it is reactive\nexport const reactiveDo = (x, f) => {\n  if (x?.[isReactive]) {\n    f(x.value)\n    return x.addReaction(() => f(x.value))\n  }\n\n  f(x)\n}\n","import { LiveFragment } from \"./live-fragment.mjs\"\nimport { isReactive, reactiveDo } from \"../reactive/index.mjs\"\n\n//#region Bruh child functions e.g. bruhChildrenToNodes()\n\n// A basic check for if a value is allowed as a child in bruh\n// It's responsible for quickly checking the type, not deep validation\nconst isBruhChild = x =>\n  // Reactives and DOM nodes\n  x?.[isReactive] ||\n  x instanceof Node ||\n  // Any array, just assume it contains valid children\n  Array.isArray(x) ||\n  // Allow nullish\n  x == null ||\n  // Disallow functions and objects\n  !(typeof x === \"function\" || typeof x === \"object\")\n  // Everything else can be a child when stringified\n\n// Coerces input into a DOM node, if it isn't already one\nconst toNode = x =>\n  x instanceof Node\n    ? x\n    : document.createTextNode(x)\n\n// Processes bruh children into an array of DOM nodes\n// Reactive values are automatically replaced, so the output must be placed into a parent node\n// before any top level (after flattening arrays) reactions run\nexport const bruhChildrenToNodes = (...children) =>\n  children\n    .flat(Infinity)\n    .flatMap(child => {\n      // Non-reactive values are untouched\n      if (!child[isReactive])\n        return [toNode(child)]\n\n      // Reactive arrays become live fragments with auto-swapped children\n      if (Array.isArray(child.value)) {\n        const liveFragment = new LiveFragment()\n        child.addReaction(() => {\n          liveFragment.replaceChildren(...bruhChildrenToNodes(...child.value))\n        })\n        return [liveFragment.startMarker, ...bruhChildrenToNodes(...child.value), liveFragment.endMarker]\n      }\n\n      // Reactive values become auto-swapped DOM nodes\n      let node = toNode(child.value)\n      child.addReaction(() => {\n        const oldNode = node\n        node = toNode(child.value)\n        oldNode.replaceWith(node)\n      })\n      return [node]\n    })\n\n//#endregion\n\n//#region Reactive-aware element helper functions e.g. applyAttributes()\n\n// Style attribute rules from an object with\n// potentially reactive and/or undefined values\nexport const applyStyles = (element, styles) => {\n  for (const property in styles)\n    reactiveDo(styles[property], value => {\n      if (value !== undefined)\n        element.style.setProperty   (property, value)\n      else\n        element.style.removeProperty(property)\n    })\n}\n\n// Class list from an object mapping from\n// class names to potentially reactive booleans\nexport const applyClasses = (element, classes) => {\n  for (const name in classes)\n    reactiveDo(classes[name], value => {\n      element.classList.toggle(name, value)\n    })\n}\n\n// Attributes from an object with\n// potentially reactive and/or undefined values\nexport const applyAttributes = (element, attributes) => {\n  for (const name in attributes)\n    reactiveDo(attributes[name], value => {\n      if (value !== undefined)\n        element.setAttribute   (name, value)\n      else\n        element.removeAttribute(name)\n    })\n}\n\n//#endregion\n\n//#region t() for text nodes and e() for element nodes\n\n// Text nodes\nexport const t = textContent => {\n  // Non-reactive values are just text nodes\n  if (!textContent[isReactive])\n    return document.createTextNode(textContent)\n\n  // Reactive values auto-update the node's text content\n  const node = document.createTextNode(textContent.value)\n  textContent.addReaction(() => {\n    node.textContent = textContent.value\n  })\n  return node\n}\n\n// Elements\nexport const e = name => (...variadic) => {\n  // If there are no props\n  if (isBruhChild(variadic[0])) {\n    const element = document.createElement(name)\n    element.append(...bruhChildrenToNodes(...variadic))\n    return element\n  }\n\n  // If props exist as the first variadic argument\n  const [props, ...children] = variadic\n\n  // Extract explicit options from the bruh prop\n  const { namespace } = props.bruh ?? {}\n  delete props.bruh\n\n  // Make an element with optional namespace\n  const element =\n    namespace\n      ? document.createElementNS(namespace, name)\n      : document.createElement  (           name)\n\n  // Apply overloaded props, if possible\n  if (typeof props.style === \"object\") {\n    applyStyles(element, props.style)\n    delete props.style\n  }\n  if (typeof props.class === \"object\") {\n    applyClasses(element, props.class)\n    delete props.class\n  }\n  // The rest of the props are attributes\n  applyAttributes(element, props)\n\n  // Add the children to the element\n  element.append(...bruhChildrenToNodes(...children))\n  return element\n}\n\n//#endregion\n\n//#region JSX integration\n\n// The function that jsx tags (except fragments) compile to\nexport const h = (nameOrComponent, props, ...children) => {\n  // If we are making an element, this is just a wrapper of e()\n  // This is likely when the JSX tag name begins with a lowercase character\n  if (typeof nameOrComponent === \"string\") {\n    const makeElement = e(nameOrComponent)\n    return props\n      ? makeElement(props, ...children)\n      : makeElement(...children)\n  }\n\n  // It must be a component, then, as bruh components are just functions\n  // Due to JSX, this would mean a function with only one parameter - props\n  // This object includes the all of the normal props and a \"children\" key\n  return nameOrComponent({ ...props, children })\n}\n\n// The JSX fragment is made into a bruh fragment (just an array)\nexport const JSXFragment = ({ children }) => children\n\n//#endregion\n\n\n\n// Hydration of all bruh-textnode's from prerendered html\nexport const hydrateTextNodes = () => {\n  const tagged = {}\n  const bruhTextNodes = document.getElementsByTagName(\"bruh-textnode\")\n\n  for (const bruhTextNode of bruhTextNodes) {\n    const textNode = document.createTextNode(bruhTextNode.textContent)\n\n    const tag = bruhTextNode.getAttribute(\"tag\")\n    if (tag)\n      tagged[tag] = textNode\n\n    bruhTextNode.replaceWith(textNode)\n  }\n\n  return tagged\n}\n","// Create a pipeline with an initial value and a series of functions\nexport const pipe = (x, ...fs) =>\n  fs.reduce((y, f) => f(y), x)\n\n// Dispatch a custom event to (capturing) and from (bubbling) a target (usually a DOM node)\n// Returns false if the event was cancelled (preventDefault()) and true otherwise\nexport const dispatch = (target, type, options) =>\n  target.dispatchEvent(\n    // Default to behave like most DOM events\n    new CustomEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      ...options\n    })\n  )\n\n// Inspired by https://antfu.me/posts/destructuring-with-object-or-array#take-away\n// Creates an object that is both destructable with {...} and [...]\n// Useful for writing library functions à la react-use & vueuse\nexport const createDestructable = (object, iterable) => {\n  const destructable = {\n    ...object,\n    [Symbol.iterator]: () => iterable[Symbol.iterator]()\n  }\n\n  Object.defineProperty(destructable, Symbol.iterator, {\n    enumerable: false\n  })\n\n  return destructable\n}\n\n// Creates an object (as a Proxy) that acts as a function\n// So functionAsObject(f).property is equivalent to f(\"property\")\n// This is can be useful when combined with destructuring syntax, e.g.:\n// const { html, head, title, body, main, h1, p } = functionAsObject(e)\nexport const functionAsObject = f =>\n  new Proxy({}, {\n    get: (_, property) => f(property)\n  })\n"],"names":[],"mappings":"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"}