{"version":3,"file":"bruh.es.js","sources":["../src/dom/live-fragment.mjs","../src/reactive/index.mjs","../src/util/index.mjs","../src/dom/index.browser.mjs"],"sourcesContent":["// Lightweight and performant DOM fragment that keeps its place,\n// useful for grouping siblings without making a parent element.\n// Not a true analog of the DocumentFragment, because the implementation\n// would be infeasible with that scope, adding a performance penalty as well.\n// Works as long as the start & end placeholders are siblings in that order\n// and they do not overlap other LiveFragment's:\n// Works: (start A)(start B)(end B)(end A)\n// Fails: (start A)(start B)(end A)(end B)\n// Also, make sure not to call .normalize() on the parent element,\n// because that would ruin the placeholders.\nexport class LiveFragment {\n  constructor() {\n    this.startMarker = document.createTextNode(\"\")\n    this.endMarker   = document.createTextNode(\"\")\n  }\n\n  static from(firstNode, lastNode) {\n    const liveFragment = new this()\n    firstNode.before(liveFragment.startMarker)\n    lastNode.after(liveFragment.endMarker)\n    return liveFragment\n  }\n\n  before(...xs) {\n    this.startMarker.before(...xs)\n  }\n\n  prepend(...xs) {\n    this.startMarker.after(...xs)\n  }\n\n  append(...xs) {\n    this.endMarker.before(...xs)\n  }\n\n  after(...xs) {\n    this.endMarker.after(...xs)\n  }\n\n  remove() {\n    const range = document.createRange()\n    range.setStartBefore(this.startMarker)\n    range.setEndAfter(this.endMarker)\n    range.deleteContents()\n  }\n\n  replaceChildren(...xs) {\n    const range = document.createRange()\n    range.setStartAfter(this.startMarker)\n    range.setEndBefore(this.endMarker)\n    range.deleteContents()\n    this.startMarker.after(...xs)\n  }\n\n  replaceWith(...xs) {\n    this.endMarker.after(...xs)\n    this.remove()\n  }\n\n  get childNodes() {\n    const childNodes = []\n\n    for (\n      let currentNode = this.startMarker.nextSibling;\n      currentNode != this.endMarker && currentNode;\n      currentNode = currentNode.nextSibling\n    )\n      childNodes.push(currentNode)\n\n    return childNodes\n  }\n\n  get children() {\n    return this.childNodes\n      .filter(node => node instanceof HTMLElement)\n  }\n}\n","const isReactive = Symbol.for(\"bruh reactive\")\n\nexport class Reactive {\n  constructor(value) {\n    this[isReactive] = true\n\n    this._value = value\n    this._reactors = new Set()\n  }\n\n  get value() {\n    return this._value\n  }\n\n  set value(newValue) {\n    if (newValue === this._value)\n      return\n\n    this._value = newValue\n    this.wasUpdated()\n\n    return newValue\n  }\n\n  wasUpdated() {\n    for (const reactor of this._reactors)\n      reactor()\n  }\n\n  react(reactor) {\n    this._reactors.add(reactor)\n\n    return () =>\n      this._reactors.delete(reactor)\n  }\n}\n\nexport const r = (xOrDependencies, f) => {\n  // If no function f is specified, make a node for x\n  if (!f)\n    return new Reactive(xOrDependencies)\n\n  // If there is a function, make a node that depends on other nodes\n  const derived = new Reactive(f())\n\n  const update = () =>\n    derived.value = f()\n  for (const dependency of xOrDependencies)\n    dependency.react(update)\n\n  return derived\n}\n\nexport const reactiveDo = (x, f) => {\n  if (x[isReactive])\n    x.react(() => f(x.value))\n  else\n    f(x)\n}\n","// Create a pipeline with an initial value and a series of functions\nexport const pipe = (x, ...fs) =>\n  fs.reduce((y, f) => f(y), x)\n\n// Dispatch a custom event to (capturing) and from (bubbling) a target (usually a DOM node)\n// Returns false if the event was cancelled (preventDefault()) and true otherwise\nexport const dispatch = (target, type, options) =>\n  target.dispatchEvent(\n    // Default to behave like most DOM events\n    new CustomEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      ...options\n    })\n  )\n\n// Inspired by https://antfu.me/posts/destructuring-with-object-or-array#take-away\n// Creates an object that is both destructable with {...} and [...]\n// Useful for writing library functions Ã  la react-use & vueuse\nexport const createDestructable = (object, iterable) => {\n  const destructable = {\n    ...object,\n    [Symbol.iterator]: () => iterable[Symbol.iterator]()\n  }\n\n  Object.defineProperty(destructable, Symbol.iterator, {\n    enumerable: false\n  })\n\n  return destructable\n}\n\n// A function that acts like Maybe.from(x).ifExists(existsThen).ifEmpty(emptyThen)\n// Except we just use an array in place of a true Maybe type\n// This is useful for setting and removing reactive attributes\nexport const maybeDo = (existsThen, emptyThen) => x => {\n  if (Array.isArray(x)) {\n    if (x.length)\n      existsThen(x[0])\n    else\n      emptyThen()\n  }\n  else\n    existsThen(x)\n}\n\n// Creates an object (as a Proxy) that acts as a function\n// So functionAsObject(f).property is equivalent to f(\"property\")\n// This is can be useful when combined with destructuring syntax, e.g.:\n// const { html, head, title, body, main, h1, p } = functionAsObject(e)\nexport const functionAsObject = f =>\n  new Proxy({}, {\n    get: (_, property) => f(property)\n  })\n","import { LiveFragment } from \"./live-fragment.mjs\"\nimport { reactiveDo } from \"../reactive/index.mjs\"\nimport { maybeDo } from \"../util/index.mjs\"\n\nconst isReactive     = Symbol.for(\"bruh reactive\")\nconst isMetaNode     = Symbol.for(\"bruh meta node\")\nconst isMetaTextNode = Symbol.for(\"bruh meta text node\")\nconst isMetaElement  = Symbol.for(\"bruh meta element\")\n\n// A basic check for if a value is allowed as a meta node's child\n// It's responsible for quickly checking the type, not deep validation\nconst isMetaNodeChild = x =>\n  (typeof x === \"object\" && x !== null)\n    // Only specific objects are allowed to be children\n    ? x[isMetaNode] ||\n      x[isReactive] ||\n      x instanceof Node ||\n      // We don't bother checking every array item, just assume it contains valid children\n      Array.isArray(x)\n    // Everything else, as long as it isn't a function, can be a child when stringified\n    : typeof x !== \"function\"\n\nconst toNode = x => {\n  if (x[isMetaNode])\n    return x.node\n\n  if (x instanceof Node)\n    return x\n\n  return document.createTextNode(x)\n}\n\nexport const childrenToNodes = children =>\n  children\n    .flat(Infinity)\n    .flatMap(child => {\n      if (!child[isReactive])\n        return [toNode(child)]\n\n      if (Array.isArray(child.value)) {\n        const liveFragment = new LiveFragment()\n        child.react(() => {\n          liveFragment.replaceChildren(...childrenToNodes(child.value))\n        })\n        return [liveFragment.startMarker, ...childrenToNodes(child.value), liveFragment.endMarker]\n      }\n\n      let node = toNode(child.value)\n      child.react(() => {\n        const oldNode = node\n        node = toNode(child.value)\n        oldNode.replaceWith(node)\n      })\n      return [node]\n    })\n\n\n\n// Meta Nodes\n\nexport class MetaTextNode {\n  constructor(textContent) {\n    this[isMetaNode] =\n    this[isMetaTextNode] = true\n\n    if (textContent[isReactive]) {\n      this.node = document.createTextNode(textContent.value)\n      textContent.react(() => {\n        this.node.textContent = textContent.value\n      })\n    }\n    else {\n      this.node = document.createTextNode(textContent)\n    }\n  }\n\n  addProperties(properties = {}) {\n    Object.assign(this.node, properties)\n\n    return this\n  }\n}\n\nexport class MetaElement {\n  constructor(name, namespace) {\n    this[isMetaNode] =\n    this[isMetaElement] = true\n\n    this.node =\n      namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement  (           name)\n  }\n\n  static from(element) {\n    const result = new this(\"div\")\n    result.node = element\n    return result\n  }\n\n  addProperties(properties = {}) {\n    Object.assign(this.node, properties)\n\n    return this\n  }\n\n  addAttributes(attributes = {}) {\n    for (const name in attributes)\n      reactiveDo(attributes[name],\n        maybeDo(\n          value => this.node.setAttribute   (name, value),\n          ()    => this.node.removeAttribute(name)\n        )\n      )\n\n    return this\n  }\n\n  addDataAttributes(dataAttributes = {}) {\n    for (const name in dataAttributes)\n      reactiveDo(dataAttributes[name],\n        maybeDo(\n          value =>        this.node.dataset[name] = value,\n          ()    => delete this.node.dataset[name]\n        )\n      )\n\n    return this\n  }\n\n  before(...xs) {\n    this.node.before(...childrenToNodes(xs))\n  }\n\n  prepend(...xs) {\n    this.node.prepend(...childrenToNodes(xs))\n  }\n\n  append(...xs) {\n    this.node.append(...childrenToNodes(xs))\n  }\n\n  after(...xs) {\n    this.node.after(...childrenToNodes(xs))\n  }\n\n  replaceChildren(...xs) {\n    this.node.replaceChildren(...childrenToNodes(xs))\n  }\n\n  replaceWith(...xs) {\n    this.node.replaceWith(...childrenToNodes(xs))\n  }\n}\n\n\n\n// Convenience functions\n\nexport const hydrateTextNodes = () => {\n  const tagged = {}\n  const bruhTextNodes = document.getElementsByTagName(\"bruh-textnode\")\n\n  for (const bruhTextNode of bruhTextNodes) {\n    const textNode = document.createTextNode(bruhTextNode.textContent)\n\n    if (bruhTextNode.dataset.tag)\n      tagged[bruhTextNode.dataset.tag] = textNode\n\n    bruhTextNode.replaceWith(textNode)\n  }\n\n  return tagged\n}\n\nconst createMetaTextNode = textContent =>\n  new MetaTextNode(textContent)\n\nconst createMetaElement = (name, namespace) => (...variadic) => {\n  const meta = new MetaElement(name, namespace)\n\n  // Implement optional attributes as first argument\n  if (!isMetaNodeChild(variadic[0])) {\n    const [attributes, ...children] = variadic\n    meta.addAttributes(attributes)\n    meta.append(children)\n  }\n  else {\n    meta.append(variadic)\n  }\n\n  return meta\n}\n\n// JSX integration\nconst createMetaElementJSX = (nameOrComponent, attributesOrProps, ...children) => {\n  // If we are making a html element\n  // This is likely when the jsx tag name begins with a lowercase character\n  if (typeof nameOrComponent == \"string\") {\n    const meta = new MetaElement(nameOrComponent)\n\n    // These are attributes then, but they might be null/undefined\n    meta.addAttributes(attributesOrProps || {})\n    meta.append(children)\n\n    return meta\n  }\n\n  // It must be a component, then\n  // Bruh components are just functions that return meta elements\n  // Due to JSX, this would mean a function with only one parameter - a \"props\" object\n  // This object includes the all of the attributes and a \"children\" key\n  return nameOrComponent( Object.assign({}, attributesOrProps, { children }) )\n}\n\n// These will be called with short names\nexport {\n  createMetaTextNode   as t,\n  createMetaElement    as e,\n  createMetaElementJSX as h\n}\n\n// The JSX fragment is made into a bruh fragment (just an array)\nexport const JSXFragment = ({ children }) => children\n"],"names":["constructor","startMarker","document","createTextNode","endMarker","firstNode","lastNode","liveFragment2","this","before","after","xs","prepend","append","remove","range","createRange","setStartBefore","setEndAfter","deleteContents","replaceChildren","setStartAfter","setEndBefore","replaceWith","childNodes","currentNode","nextSibling","push","filter","node","HTMLElement","isReactive","Symbol","for","value","_value","_reactors","Set","newValue","wasUpdated","reactor","react","add","delete","reactiveDo","x","f","xOrDependencies","Reactive","derived","update","dependency","maybeDo","existsThen","emptyThen","Array","isArray","length","fs","reduce","y","target","type","options","dispatchEvent","CustomEvent","__spreadValues","bubbles","cancelable","composed","object","iterable","destructable","iterator","defineProperty","enumerable","Proxy","get","_","property","isMetaNode","isMetaTextNode","isMetaElement","toNode","Node","childrenToNodes","children","flat","Infinity","flatMap","child","LiveFragment","oldNode","textContent","addProperties","properties","assign","name","namespace","createElementNS","createElement","element","result","addAttributes","attributes","setAttribute","removeAttribute","addDataAttributes","dataAttributes","dataset","tagged","bruhTextNodes","getElementsByTagName","bruhTextNode","textNode","tag","MetaTextNode","variadic","meta","MetaElement","nameOrComponent","attributesOrProps","Object"],"mappings":"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"}